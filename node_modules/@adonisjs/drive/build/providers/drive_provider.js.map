{"version":3,"sources":["../../providers/drive_provider.ts","../../src/file_server.ts"],"sourcesContent":["/*\n * @adonisjs/drive\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Disk, DriveManager } from 'flydrive'\nimport { configProvider } from '@adonisjs/core'\nimport { MultipartFile } from '@adonisjs/core/bodyparser'\nimport { RuntimeException } from '@adonisjs/core/exceptions'\nimport type { ApplicationService } from '@adonisjs/core/types'\n\nimport debug from '../src/debug.js'\nimport { createFileServer } from '../src/file_server.js'\nimport type {\n  DriveDisks,\n  DriveService,\n  WriteOptions,\n  SignedURLOptions,\n  ServiceWithLocalServer,\n} from '../src/types.js'\n\n/**\n * Extending the container with a custom service\n */\ndeclare module '@adonisjs/core/types' {\n  interface ContainerBindings {\n    'drive.manager': DriveService\n  }\n}\n\n/**\n * Extending BodyParser Multipart file with \"moveToDisk\"\n * method to move file from the local filesystem to\n * a drive disk\n */\ndeclare module '@adonisjs/core/bodyparser' {\n  interface MultipartFile {\n    /**\n     * Move user uploaded file from the tmp directory\n     * to a Drive disk\n     */\n    moveToDisk(key: string, disk?: keyof DriveDisks, options?: WriteOptions): Promise<void>\n    moveToDisk(key: string, options?: WriteOptions): Promise<void>\n  }\n}\n\n/**\n * Drive Provider registers a singleton drive manager services\n * to the IoC container and wires up the routing to serve\n * files from the \"fs\" driver.\n */\nexport default class DriveProvider {\n  /**\n   * Collection of services using the \"fs\" driver and want\n   * to serve files using the AdonisJS HTTP server.\n   */\n  #locallyServedServices: ServiceWithLocalServer[] = []\n\n  constructor(protected app: ApplicationService) {}\n\n  /**\n   * Defines the template engine on the message class to\n   * render templates\n   */\n  protected async registerViewHelpers(drive: DriveManager<any>) {\n    if (this.app.usingEdgeJS) {\n      const edge = await import('edge.js')\n      debug('detected edge installation. Registering drive global helpers')\n\n      edge.default.global('driveUrl', function (key: string, diskName?: string) {\n        const disk = diskName ? drive.use(diskName) : drive.use()\n        return disk.getUrl(key)\n      })\n\n      edge.default.global(\n        'driveSignedUrl',\n        function (\n          key: string,\n          diskNameOrOptions?: string | SignedURLOptions,\n          signedUrlOptions?: SignedURLOptions\n        ) {\n          let diskName: string | undefined\n          let options: SignedURLOptions | undefined = signedUrlOptions\n\n          if (typeof diskNameOrOptions === 'string') {\n            diskName = diskNameOrOptions\n          } else if (diskNameOrOptions && !signedUrlOptions) {\n            options = diskNameOrOptions\n          }\n\n          const disk = diskName ? drive.use(diskName) : drive.use()\n          return disk.getSignedUrl(key, options)\n        }\n      )\n    }\n  }\n\n  /**\n   * Extending BodyParser Multipart file with \"moveToDisk\"\n   * method to move file from the local filesystem to\n   * a drive disk\n   */\n  protected async extendMultipartFile(drive: DriveManager<any>) {\n    debug('Adding \"MultipartFile.moveToDisk\" method')\n\n    MultipartFile.macro(\n      'moveToDisk',\n      async function (this: MultipartFile, key, diskNameOrOptions?, writeOptions?) {\n        if (!this.tmpPath) {\n          throw new RuntimeException(\n            'property \"tmpPath\" must be set on the file before moving it',\n            {\n              status: 500,\n              code: 'E_MISSING_FILE_TMP_PATH',\n            }\n          )\n        }\n\n        let diskName: string | undefined\n        let options: WriteOptions | undefined\n\n        if (typeof diskNameOrOptions === 'string') {\n          diskName = diskNameOrOptions\n        } else if (diskNameOrOptions && !writeOptions) {\n          options = diskNameOrOptions\n        } else if (writeOptions) {\n          options = writeOptions\n        }\n\n        const disk = diskName ? drive.use(diskName) : drive.use()\n        return disk.moveFromFs(this.tmpPath, key, options)\n      }\n    )\n  }\n\n  register() {\n    this.app.container.singleton('drive.manager', async () => {\n      /**\n       * Resolving config from the \"config/drive.ts\" file and\n       * expecting it to be a config provider.\n       */\n      const driveConfigProvider = this.app.config.get('drive')\n      const config = await configProvider.resolve<{\n        config: any\n        locallyServed: ServiceWithLocalServer[]\n      }>(this.app, driveConfigProvider)\n\n      /**\n       * Ensure the returned value is the output of the\n       * config provider\n       */\n      if (!config) {\n        throw new RuntimeException(\n          'Invalid \"config/drive.ts\" file. Make sure you are using the \"defineConfig\" method'\n        )\n      }\n\n      /**\n       * Keep a reference of services to be served locally\n       */\n      this.#locallyServedServices = config.locallyServed\n      return new DriveManager(config.config)\n    })\n\n    this.app.container.bind(Disk, async (resolver) => {\n      const driveManager = await resolver.make('drive.manager')\n      return driveManager.use()\n    })\n  }\n\n  /**\n   * The boot method resolves drive and router to register\n   * the routes for the locally served services.\n   *\n   * The routes must be defined before the application has\n   * started.\n   */\n  async boot() {\n    const drive = await this.app.container.make('drive.manager')\n    const router = await this.app.container.make('router')\n\n    this.#locallyServedServices.forEach((service) => {\n      debug(\n        'configuring drive local file server for \"%s\", route \"%s\"',\n        service.service,\n        service.routePattern\n      )\n      router\n        .get(service.routePattern, createFileServer(drive.use(service.service)))\n        .as(service.routeName)\n    })\n\n    await this.registerViewHelpers(drive)\n    await this.extendMultipartFile(drive)\n  }\n}\n","/*\n * @adonisjs/drive\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { HttpContext } from '@adonisjs/core/http'\n\nimport debug from './debug.js'\nimport type { Disk } from '../index.js'\nimport { CannotServeFileException } from './errors.js'\n\nfunction decodeLocation(location: string): string {\n  try {\n    return decodeURIComponent(location)\n  } catch {\n    return location\n  }\n}\n\n/**\n * Returns a file server function that can be registered as\n * a route to serve files from a specific disk instance.\n */\nexport function createFileServer(disk: Disk) {\n  return async function ({ request, response }: HttpContext) {\n    const location = decodeLocation(request.param('*').join('/'))\n\n    /**\n     * Grabbing an instance of DriveFile. DriveFile will ensure\n     * the path does not have any path traversal segments and\n     * will throw an exception.\n     */\n    const file = disk.file(location)\n\n    /**\n     * Getting the visibility of the file. Private files won't be\n     * served without signatures.\n     */\n    const visibility = await file.getVisibility()\n    const isPrivate = visibility === 'private'\n\n    /**\n     * Check if the current URL is using a signature and\n     * also if the signature is valid. We need both\n     * for the following use-cases.\n     *\n     * - When a signature is present, we infer response\n     *   headers from the request query string.\n     * - So we have to make sure that when a signature\n     *   is present, it should also be valid.\n     * - Public files can be served without a\n     *   signature.\n     * - But if someone uses a fake signature on a public\n     *   file to trick the response headers, then we\n     *   should deny the request.\n     */\n    const usingSignature = !!request.input('signature')\n    const hasValidSignature = request.hasValidSignature()\n\n    /**\n     * Deny when file is private and a valid signature is\n     * not presented.\n     *\n     * Or a signature is presented but it is invalid. Regardless\n     * of the file visibility\n     */\n    if ((isPrivate && !hasValidSignature) || (usingSignature && !hasValidSignature)) {\n      debug('Access denied for file \"%s\". Failed condition %o', location, {\n        isPrivate,\n        hasValidSignature,\n        usingSignature,\n      })\n      return response.unauthorized('Access denied')\n    }\n\n    /**\n     * Read https://datatracker.ietf.org/doc/html/rfc7234#section-4.3.5 for\n     * headers management\n     */\n    try {\n      const metadata = await file.getMetaData()\n\n      response.header('etag', metadata.etag)\n\n      /**\n       * Set Last-Modified or the Cache-Control header. We pick\n       * the cache control header from the query string only\n       * when a valid signature is presented.\n       */\n      if (usingSignature && request.input('cacheControl')) {\n        response.header('Cache-Control', request.input('cacheControl'))\n      } else {\n        response.header('Last-Modified', metadata.lastModified.toUTCString())\n      }\n\n      /**\n       * Set the Content-Type header. We pick the contentType header\n       * from the query string only when a valid signature\n       * is presented\n       */\n      if (usingSignature && request.input('contentType')) {\n        response.header('Content-Type', request.input('contentType'))\n      } else if (metadata.contentType) {\n        response.type(metadata.contentType)\n      }\n\n      /**\n       * Set the following headers by reading the query string values.\n       * Must be done when a signature was presented.\n       */\n      if (usingSignature && request.input('contentDisposition')) {\n        response.header('Content-Disposition', request.input('contentDisposition'))\n      }\n      if (usingSignature && request.input('contentEncoding')) {\n        response.header('Content-Encoding', request.input('contentEncoding'))\n      }\n      if (usingSignature && request.input('contentLanguage')) {\n        response.header('Content-Language', request.input('contentLanguage'))\n      }\n\n      /*\n       * Do not stream files for HEAD request, but set the appropriate\n       * status code.\n       *\n       * 200: When NOT using etags or cache is NOT fresh. This forces browser\n       *      to always make a GET request\n       *\n       * 304: When etags are used and cache is fresh\n       */\n      if (request.method() === 'HEAD') {\n        response.status(response.fresh() ? 304 : 200)\n        return\n      }\n\n      /*\n       * Regardless of request method, if cache is\n       * fresh, then we must respond with 304\n       */\n      if (response.fresh()) {\n        response.status(304)\n        return\n      }\n\n      /**\n       * Set content length if serving the file\n       */\n      response.header('Content-length', metadata.contentLength.toString())\n\n      /**\n       * Get file stream and send it in the response\n       */\n      return response.stream(await file.getStream())\n    } catch (error) {\n      throw new CannotServeFileException(error)\n    }\n  }\n}\n"],"mappings":"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","names":[]}