{"version":3,"sources":["../drivers/fs/driver.ts","../drivers/fs/debug.ts"],"sourcesContent":["/*\n * flydrive\n *\n * (c) FlyDrive\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport etag from 'etag'\nimport mimeTypes from 'mime-types'\nimport { Readable } from 'node:stream'\nimport { slash } from '@poppinss/utils'\nimport * as fsp from 'node:fs/promises'\nimport { fileURLToPath } from 'node:url'\nimport { Retrier } from '@humanwhocodes/retry'\nimport { RuntimeException } from '@poppinss/utils'\nimport { dirname, join, relative } from 'node:path'\nimport { existsSync, rmSync, createReadStream, Dirent } from 'node:fs'\n\nimport debug from './debug.js'\nimport type { FSDriverOptions } from './types.js'\nimport { DriveFile } from '../../src/driver_file.js'\nimport { DriveDirectory } from '../../src/drive_directory.js'\nimport type {\n  WriteOptions,\n  ObjectMetaData,\n  DriverContract,\n  ObjectVisibility,\n  SignedURLOptions,\n} from '../../src/types.js'\n\n/**\n * The error codes on which we want to retry fs\n * operations\n */\nconst RETRY_ERROR_CODES = new Set(['ENFILE', 'EMFILE'])\n\n/**\n * Implementation of FlyDrive driver that uses the local filesystem\n * to persist and read files.\n */\nexport class FSDriver implements DriverContract {\n  /**\n   * The root directory for the driver\n   */\n  #rootUrl: string\n\n  /**\n   * Retrier is used to retry file system operations\n   * when certain errors are raised.\n   */\n  #retrier = new Retrier(\n    (error: NodeJS.ErrnoException) => error.code && RETRY_ERROR_CODES.has(error.code)\n  )\n\n  constructor(public options: FSDriverOptions) {\n    this.#rootUrl =\n      typeof options.location === 'string' ? options.location : fileURLToPath(options.location)\n\n    debug('driver config %O', options)\n  }\n\n  /**\n   * Reads the file for the provided path\n   */\n  #read(key: string): Promise<Buffer> {\n    const location = join(this.#rootUrl, key)\n    return this.#retrier.retry(() => fsp.readFile(location))\n  }\n\n  /**\n   * Reads dir and ignores non-existing errors\n   */\n  async #readDir(location: string, recursive: boolean): Promise<Dirent[]> {\n    try {\n      return await fsp.readdir(location, {\n        recursive,\n        withFileTypes: true,\n      })\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        throw error\n      }\n      return []\n    }\n  }\n\n  /**\n   * Generic implementation to write a file\n   */\n  #write(\n    key: string,\n    contents: string | Readable | Uint8Array,\n    options?: { signal?: AbortSignal }\n  ) {\n    const location = join(this.#rootUrl, key)\n    return this.#retrier.retry(async () => {\n      await fsp.mkdir(dirname(location), { recursive: true })\n      await fsp.writeFile(location, contents, options)\n    })\n  }\n\n  /**\n   * Synchronously check if a file exists\n   */\n  existsSync(key: string): boolean {\n    debug('checking if file exists %s:%s', this.#rootUrl, key)\n    const location = join(this.#rootUrl, key)\n    return existsSync(location)\n  }\n\n  /**\n   * Returns a boolean indicating if the file exists or not.\n   */\n  async exists(key: string): Promise<boolean> {\n    debug('checking if file exists %s:%s', this.#rootUrl, key)\n    const location = join(this.#rootUrl, key)\n    try {\n      const object = await fsp.stat(location)\n      return object.isFile()\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        return false\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Returns the contents of the file as a UTF-8 string. An\n   * exception is thrown when the file is missing.\n   */\n  async get(key: string): Promise<string> {\n    debug('reading file contents %s:%s', this.#rootUrl, key)\n    return this.#read(key).then((value) => value.toString('utf-8'))\n  }\n\n  /**\n   * Returns the contents of the file as a stream. An\n   * exception is thrown when the file is missing.\n   */\n  async getStream(key: string): Promise<Readable> {\n    debug('reading file contents as a stream %s:%s', this.#rootUrl, key)\n    const location = join(this.#rootUrl, key)\n    return createReadStream(location)\n  }\n\n  /**\n   * Returns the contents of the file as an Uint8Array. An\n   * exception is thrown when the file is missing.\n   */\n  async getBytes(key: string): Promise<Uint8Array> {\n    debug('reading file contents as array buffer %s:%s', this.#rootUrl, key)\n    return this.#read(key).then((value) => new Uint8Array(value.buffer))\n  }\n\n  /**\n   * Returns the metadata of a file.\n   */\n  async getMetaData(key: string): Promise<ObjectMetaData> {\n    debug('fetching file metadata %s:%s', this.#rootUrl, key)\n    const location = join(this.#rootUrl, key)\n    const stats = await fsp.stat(location)\n\n    if (stats.isDirectory()) {\n      throw new RuntimeException(`Cannot get metadata of a directory \"${key}\"`)\n    }\n\n    return {\n      contentLength: stats.size,\n      contentType: mimeTypes.lookup(key) || undefined,\n      etag: etag(stats),\n      lastModified: stats.mtime,\n    }\n  }\n\n  /**\n   * Returns the file visibility from the pre-defined config\n   * value\n   */\n  async getVisibility(_: string): Promise<ObjectVisibility> {\n    return this.options.visibility\n  }\n\n  /**\n   * Returns the public URL of the file. This method does not check\n   * if the file exists or not.\n   */\n  async getUrl(key: string): Promise<string> {\n    const location = join(this.#rootUrl, key)\n    const generateURL = this.options.urlBuilder?.generateURL\n    if (generateURL) {\n      debug('generating public URL %s:%s', this.#rootUrl, key)\n      return generateURL(key, location)\n    }\n\n    throw new RuntimeException('Cannot generate URL. The \"fs\" driver does not support it')\n  }\n\n  /**\n   * Returns the signed/temporary URL of the file. By default, the signed URLs\n   * expire in 30mins, but a custom expiry can be defined using\n   * \"options.expiresIn\" property.\n   */\n  async getSignedUrl(key: string, options?: SignedURLOptions): Promise<string> {\n    const location = join(this.#rootUrl, key)\n    const normalizedOptions = Object.assign(\n      {\n        expiresIn: '30 mins',\n      },\n      options\n    )\n\n    /**\n     * Use custom implementation when exists.\n     */\n    const generateSignedURL = this.options.urlBuilder?.generateSignedURL\n    if (generateSignedURL) {\n      debug('generating signed URL %s:%s', this.#rootUrl, key)\n      return generateSignedURL(key, location, normalizedOptions)\n    }\n\n    throw new RuntimeException('Cannot generate signed URL. The \"fs\" driver does not support it')\n  }\n\n  /**\n   * Results in noop, since the local filesystem cannot have per\n   * object visibility.\n   */\n  async setVisibility(_: string, __: ObjectVisibility): Promise<void> {}\n\n  /**\n   * Writes a file to the destination with the provided contents.\n   *\n   * - Missing directories will be created recursively.\n   * - Existing file will be overwritten.\n   */\n  put(key: string, contents: string | Uint8Array, options?: WriteOptions): Promise<void> {\n    debug('creating/updating file %s:%s', this.#rootUrl, key)\n    return this.#write(key, contents, { signal: options?.signal })\n  }\n\n  /**\n   * Writes a file to the destination with the provided contents\n   * as a readable stream.\n   *\n   * - Missing directories will be created recursively.\n   * - Existing file will be overwritten.\n   */\n  putStream(key: string, contents: Readable, options?: WriteOptions): Promise<void> {\n    debug('creating/updating file using readable stream %s:%s', this.#rootUrl, key)\n    return new Promise((resolve, reject) => {\n      contents.once('error', (error) => reject(error))\n      return this.#write(key, contents, { signal: options?.signal }).then(resolve).catch(reject)\n    })\n  }\n\n  /**\n   * Copies the source file to the destination. Both paths must\n   * be within the root location.\n   */\n  copy(source: string, destination: string): Promise<void> {\n    debug('copying file from %s to %s', source, destination)\n    const sourceLocation = join(this.#rootUrl, source)\n    const destinationLocation = join(this.#rootUrl, destination)\n\n    return this.#retrier.retry(async () => {\n      await fsp.mkdir(dirname(destinationLocation), { recursive: true })\n      await fsp.copyFile(sourceLocation, destinationLocation)\n    })\n  }\n\n  /**\n   * Moves the source file to the destination. Both paths must\n   * be within the root location.\n   */\n  move(source: string, destination: string): Promise<void> {\n    debug('moving file from %s to %s', source, destination)\n    const sourceLocation = join(this.#rootUrl, source)\n    const destinationLocation = join(this.#rootUrl, destination)\n\n    return this.#retrier.retry(async () => {\n      await fsp.mkdir(dirname(destinationLocation), { recursive: true })\n      await fsp.copyFile(sourceLocation, destinationLocation)\n      await fsp.unlink(sourceLocation)\n    })\n  }\n\n  /**\n   * Deletes a file within the root location of the filesystem.\n   * Attempting to delete a non-existing file will result in\n   * a noop.\n   */\n  delete(key: string): Promise<void> {\n    debug('deleting file %s:%s', this.#rootUrl, key)\n    const location = join(this.#rootUrl, key)\n\n    return this.#retrier.retry(async () => {\n      try {\n        await fsp.unlink(location)\n      } catch (error) {\n        if (error.code !== 'ENOENT') {\n          throw error\n        }\n      }\n    })\n  }\n\n  /**\n   * Deletes the files and directories matching the provided\n   * prefix. The method is same as running \"rm -rf\" unix\n   * command\n   */\n  deleteAll(prefix: string): Promise<void> {\n    debug('deleting all files in folder %s:%s', this.#rootUrl, prefix)\n    const location = join(this.#rootUrl, prefix)\n\n    return this.#retrier.retry(async () => {\n      return fsp.rm(location, { recursive: true, force: true })\n    })\n  }\n\n  /**\n   * Synchronously delete all files from the root location\n   */\n  clearSync() {\n    rmSync(this.#rootUrl, { recursive: true, force: true })\n  }\n\n  /**\n   * Returns a list of files. The pagination properties are ignored\n   * by the fs driver, since it does not support pagination.\n   */\n  async listAll(\n    prefix: string,\n    options?: {\n      recursive?: boolean\n      paginationToken?: string\n    }\n  ): Promise<{\n    paginationToken?: string\n    objects: Iterable<DriveFile | DriveDirectory>\n  }> {\n    const self = this\n    const location = join(this.#rootUrl, prefix)\n    const { recursive } = Object.assign({ recursive: false }, options)\n    debug('listing files from folder %s:%s %O', this.#rootUrl, prefix, options)\n\n    /**\n     * Reading files with their types.\n     */\n    const files = await this.#readDir(location, recursive)\n\n    /**\n     * The generator is used to lazily iterate over files and\n     * convert them into DriveFile or DriveDirectory instances\n     */\n    function* filesGenerator(): Iterator<\n      DriveFile | { isFile: false; isDirectory: true; prefix: string; name: string }\n    > {\n      for (const file of files) {\n        const relativeName = slash(\n          relative(self.#rootUrl, join(file.parentPath || file.path, file.name))\n        )\n        if (file.isFile()) {\n          yield new DriveFile(relativeName, self)\n        } else if (!recursive) {\n          yield new DriveDirectory(relativeName)\n        }\n      }\n    }\n\n    return {\n      paginationToken: undefined,\n      objects: {\n        [Symbol.iterator]: filesGenerator,\n      },\n    }\n  }\n}\n","/*\n * flydrive\n *\n * (c) FlyDrive\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { debuglog } from 'node:util'\n\nexport default debuglog('flydrive:fs')\n"],"mappings":"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","names":[]}