{"version":3,"sources":["../../../drivers/gcs/driver.ts","../../../drivers/gcs/debug.ts"],"sourcesContent":["/*\n * flydrive\n *\n * (c) FlyDrive\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { type Readable } from 'node:stream'\nimport string from '@poppinss/utils/string'\nimport {\n  Storage,\n  SaveOptions,\n  FileMetadata,\n  GetFilesOptions,\n  GetSignedUrlConfig,\n} from '@google-cloud/storage'\n\nimport debug from './debug.js'\nimport type { GCSDriverOptions } from './types.js'\nimport { DriveFile } from '../../src/driver_file.js'\nimport { DriveDirectory } from '../../src/drive_directory.js'\nimport type {\n  WriteOptions,\n  ObjectMetaData,\n  DriverContract,\n  SignedURLOptions,\n  ObjectVisibility,\n} from '../../src/types.js'\n\n/**\n * Implementation of FlyDrive driver that reads and persists files\n * to Google cloud storage service\n */\nexport class GCSDriver implements DriverContract {\n  #storage: Storage\n  #usingUniformAcl: boolean = true\n\n  constructor(public options: GCSDriverOptions) {\n    this.#storage = 'storage' in options ? options.storage : new Storage(options)\n    if (options.usingUniformAcl !== undefined) {\n      this.#usingUniformAcl = options.usingUniformAcl\n    }\n\n    if (debug.enabled) {\n      debug('driver config %O', {\n        ...options,\n        credentials: 'REDACTED',\n      })\n    }\n  }\n\n  /**\n   * Returns GCS options for the save operations.\n   */\n  #getSaveOptions(options?: WriteOptions): SaveOptions {\n    /**\n     * Destructuring known properties and creating a new object\n     * with the rest of unknown properties.\n     */\n    const {\n      visibility, // used locally\n      contentType, // forwaded as metadata\n      cacheControl, // forwaded as metadata\n      contentEncoding, // forwaded as metadata\n      contentLength, // not entertained by GCS\n      contentLanguage, // not entertained by GCS\n      contentDisposition, // not entertained by GCS\n      ...rest // forwarded as it is\n    } = options || {}\n\n    /**\n     * Creating GCS options with all the unknown properties and empty\n     * metadata object. We will later fill this metadata object\n     * with the known options.\n     */\n    const gcsOptions: SaveOptions = { resumable: false, ...rest }\n    gcsOptions.metadata = Object.assign(gcsOptions.metadata || {}, {\n      contentType,\n      cacheControl,\n      contentEncoding,\n    })\n\n    /**\n     * Assign ACL to the object when not using uniform ACL\n     * on the bucket or project.\n     */\n    if (this.#usingUniformAcl === false) {\n      gcsOptions.public = (visibility || this.options.visibility) === 'public'\n      gcsOptions.private = !gcsOptions.public\n      gcsOptions.predefinedAcl = gcsOptions.public ? 'publicRead' : 'private'\n    }\n\n    debug('gcs write options %O', gcsOptions)\n    return gcsOptions\n  }\n\n  /**\n   * Creates the metadata for the file from the raw response\n   * returned by GCS\n   */\n  #createFileMetaData(apiFile: FileMetadata) {\n    const metaData: ObjectMetaData = {\n      contentType: apiFile.contentType,\n      contentLength: Number(apiFile.size!),\n      etag: apiFile.etag!,\n      lastModified: new Date(apiFile.updated!),\n    }\n\n    debug('file metadata %O', this.options.bucket, metaData)\n    return metaData\n  }\n\n  /**\n   * Returns the GCS objects using the callback approach, since there\n   * is no other way to get access to the API response and the\n   * pagination token\n   *\n   * Instead of using \"bucket.getFiles\" we use \"bucket.request\", because\n   * the \"getFiles\" method internally creates an instance of \"File\".\n   * We do not even need this instance and wasting resources when\n   * querying a bucket with many files.\n   */\n  #getGCSObjects(\n    options: GetFilesOptions\n  ): Promise<{ files: FileMetadata[]; prefixes: string[]; paginationToken?: string }> {\n    const bucket = this.#storage.bucket(this.options.bucket)\n    debug('fetching files list %O', options)\n\n    return new Promise((resolve, reject) => {\n      bucket.request(\n        {\n          uri: '/o',\n          qs: options,\n        },\n        (error, response) => {\n          if (error) {\n            debug('list files API error %O', error)\n            reject(error)\n          } else {\n            debug('list files API response %O', response)\n            resolve({\n              files: response.items || [],\n              paginationToken: response.nextPageToken,\n              prefixes: response.prefixes || [],\n            })\n          }\n        }\n      )\n    })\n  }\n\n  /**\n   * Returns a boolean indicating if the file exists\n   * or not.\n   */\n  async exists(key: string): Promise<boolean> {\n    debug('checking if file exists %s:%s', this.options.bucket, key)\n    const bucket = this.#storage.bucket(this.options.bucket)\n\n    const response = await bucket.file(key).exists()\n    return response[0]\n  }\n\n  /**\n   * Returns the contents of a file as a UTF-8 string. An\n   * exception is thrown when object is missing.\n   */\n  async get(key: string): Promise<string> {\n    debug('reading file contents %s:%s', this.options.bucket, key)\n    const bucket = this.#storage.bucket(this.options.bucket)\n\n    const response = await bucket.file(key).download()\n    return response[0].toString('utf-8')\n  }\n\n  /**\n   * Returns the contents of the file as a Readable stream. An\n   * exception is thrown when the file is missing.\n   */\n  async getStream(key: string): Promise<Readable> {\n    debug('reading file contents as a stream %s:%s', this.options.bucket, key)\n    const bucket = this.#storage.bucket(this.options.bucket)\n\n    return bucket.file(key).createReadStream()\n  }\n\n  /**\n   * Returns the contents of the file as an Uint8Array. An\n   * exception is thrown when the file is missing.\n   */\n  async getBytes(key: string): Promise<Uint8Array> {\n    debug('reading file contents as array buffer %s:%s', this.options.bucket, key)\n    const bucket = this.#storage.bucket(this.options.bucket)\n\n    const response = await bucket.file(key).download()\n    return new Uint8Array(response[0])\n  }\n\n  /**\n   * Returns the file metadata.\n   */\n  async getMetaData(key: string): Promise<ObjectMetaData> {\n    debug('fetching file metadata %s:%s', this.options.bucket, key)\n    const bucket = this.#storage.bucket(this.options.bucket)\n\n    const response = await bucket.file(key).getMetadata()\n    return this.#createFileMetaData(response[0])\n  }\n\n  /**\n   * Returns the visibility of a file\n   */\n  async getVisibility(key: string): Promise<ObjectVisibility> {\n    debug('fetching file visibility %s:%s', this.options.bucket, key)\n    const bucket = this.#storage.bucket(this.options.bucket)\n\n    const [isFilePublic] = await bucket.file(key).isPublic()\n    return isFilePublic ? 'public' : 'private'\n  }\n\n  /**\n   * Returns the public URL of the file. This method does not check\n   * if the file exists or not.\n   */\n  async getUrl(key: string): Promise<string> {\n    /**\n     * Use custom implementation when exists.\n     */\n    const generateURL = this.options.urlBuilder?.generateURL\n    if (generateURL) {\n      debug('using custom implementation for generating public URL %s:%s', this.options.bucket, key)\n      return generateURL(key, this.options.bucket, this.#storage)\n    }\n\n    debug('generating public URL %s:%s', this.options.bucket, key)\n    const bucket = this.#storage.bucket(this.options.bucket)\n    const file = bucket.file(key)\n    return file.publicUrl()\n  }\n\n  /**\n   * Returns the signed/temporary URL of the file. By default, the signed URLs\n   * expire in 30mins, but a custom expiry can be defined using\n   * \"options.expiresIn\" property.\n   */\n  async getSignedUrl(key: string, options?: SignedURLOptions): Promise<string> {\n    const { contentDisposition, contentType, expiresIn, ...rest } = Object.assign({}, options)\n\n    /**\n     * Options passed to GCS when generating the signed URL.\n     */\n    const expires = new Date()\n    expires.setSeconds(new Date().getSeconds() + string.seconds.parse(expiresIn || '30mins'))\n\n    const signedURLOptions: GetSignedUrlConfig = {\n      action: 'read',\n      expires: expires,\n      responseType: contentType,\n      responseDisposition: contentDisposition,\n      ...rest,\n    }\n\n    /**\n     * Use custom implementation when exists.\n     */\n    const generateSignedURL = this.options.urlBuilder?.generateSignedURL\n    if (generateSignedURL) {\n      debug('using custom implementation for generating signed URL %s:%s', this.options.bucket, key)\n      return generateSignedURL(key, this.options.bucket, signedURLOptions, this.#storage)\n    }\n\n    debug('generating signed URL %s:%s', this.options.bucket, key)\n    const bucket = this.#storage.bucket(this.options.bucket)\n    const file = bucket.file(key)\n\n    const response = await file.getSignedUrl(signedURLOptions)\n    return response[0]\n  }\n\n  /**\n   * Updates the visibility of a file\n   */\n  async setVisibility(key: string, visibility: ObjectVisibility): Promise<void> {\n    debug('updating file visibility %s:%s to %s', this.options.bucket, key, visibility)\n    const bucket = this.#storage.bucket(this.options.bucket)\n\n    const file = bucket.file(key)\n    if (visibility === 'private') {\n      await file.makePrivate()\n    } else {\n      await file.makePublic()\n    }\n  }\n\n  /**\n   * Writes a file to the bucket for the given key and contents.\n   */\n  async put(\n    key: string,\n    contents: string | Uint8Array,\n    options?: WriteOptions | undefined\n  ): Promise<void> {\n    debug('creating/updating file %s:%s', this.options.bucket, key)\n    const bucket = this.#storage.bucket(this.options.bucket)\n    await bucket.file(key).save(Buffer.from(contents), this.#getSaveOptions(options))\n  }\n\n  /**\n   * Writes a file to the bucket for the given key and stream\n   */\n  putStream(key: string, contents: Readable, options?: WriteOptions | undefined): Promise<void> {\n    debug('creating/updating file using readable stream %s:%s', this.options.bucket, key)\n    const bucket = this.#storage.bucket(this.options.bucket)\n\n    return new Promise((resolve, reject) => {\n      /**\n       * GCS internally creates a pipeline of stream and invokes the \"_destroy\" method\n       * at several occassions. Because of that, the \"_destroy\" method emits an event\n       * which cannot handled within this block of code.\n       *\n       * So the only way I have been able to make GCS streams work is by ditching the\n       * pipeline method and relying on the \"pipe\" method instead.\n       */\n      const writeable = bucket.file(key).createWriteStream(this.#getSaveOptions(options))\n      writeable.once('error', reject)\n      contents.once('error', reject)\n      contents.pipe(writeable).on('finish', resolve).on('error', reject)\n    })\n  }\n\n  /**\n   * Copies the source file to the destination. Both paths must\n   * be within the root location.\n   */\n  async copy(source: string, destination: string, options?: WriteOptions): Promise<void> {\n    debug(\n      'copying file from %s:%s to %s:%s',\n      this.options.bucket,\n      source,\n      this.options.bucket,\n      destination\n    )\n    const bucket = this.#storage.bucket(this.options.bucket)\n    options = options || {}\n\n    /**\n     * Copy visibility from the source file to the\n     * desintation when no inline visibility is\n     * defined and not using usingUniformAcl\n     */\n    if (!options.visibility && !this.#usingUniformAcl) {\n      const [isFilePublic] = await bucket.file(source).isPublic()\n      options.visibility = isFilePublic ? 'public' : 'private'\n    }\n\n    await bucket.file(source).copy(destination, this.#getSaveOptions(options))\n  }\n\n  /**\n   * Moves the source file to the destination. Both paths must\n   * be within the root location.\n   */\n  async move(source: string, destination: string, options?: WriteOptions): Promise<void> {\n    debug(\n      'moving file from %s:%s to %s:%s',\n      this.options.bucket,\n      source,\n      this.options.bucket,\n      destination\n    )\n\n    const bucket = this.#storage.bucket(this.options.bucket)\n    options = options || {}\n\n    /**\n     * Copy visibility from the source file to the\n     * desintation when no inline visibility is\n     * defined and not using usingUniformAcl\n     */\n    if (!options.visibility && !this.#usingUniformAcl) {\n      const [isFilePublic] = await bucket.file(source).isPublic()\n      options.visibility = isFilePublic ? 'public' : 'private'\n    }\n\n    await bucket.file(source).move(destination, this.#getSaveOptions(options))\n  }\n\n  /**\n   * Deletes the object from the bucket\n   */\n  async delete(key: string) {\n    debug('removing file %s:%s', this.options.bucket, key)\n    const bucket = this.#storage.bucket(this.options.bucket)\n    await bucket.file(key).delete({ ignoreNotFound: true })\n  }\n\n  /**\n   * Deletes the files and directories matching the provided\n   * prefix.\n   */\n  async deleteAll(prefix: string): Promise<void> {\n    const bucket = this.#storage.bucket(this.options.bucket)\n    debug('removing all files matching prefix %s:%s', this.options.bucket, prefix)\n    await bucket.deleteFiles({ prefix: `${prefix.replace(/\\/$/, '')}/` })\n  }\n\n  /**\n   * Returns a list of files. The pagination token can be used to paginate\n   * through the files.\n   */\n  async listAll(\n    prefix: string,\n    options?: {\n      recursive?: boolean\n      paginationToken?: string\n      maxResults?: number\n    }\n  ): Promise<{\n    paginationToken?: string\n    objects: Iterable<DriveFile | DriveDirectory>\n  }> {\n    const self = this\n    let { recursive, paginationToken, maxResults } = Object.assign({ recursive: false }, options)\n    if (prefix) {\n      prefix = !recursive ? `${prefix.replace(/\\/$/, '')}/` : prefix\n    }\n\n    debug('listing all files matching prefix %s:%s', this.options.bucket, prefix)\n\n    const response = await this.#getGCSObjects({\n      autoPaginate: false,\n      delimiter: !recursive ? '/' : '',\n      includeTrailingDelimiter: !recursive,\n      includeFoldersAsPrefixes: !recursive,\n      pageToken: paginationToken,\n      ...(prefix !== '/' ? { prefix } : {}),\n      ...(maxResults !== undefined ? { maxResults } : {}),\n    })\n\n    /**\n     * The generator is used to lazily iterate over files and\n     * convert them into DriveFile or DriveDirectory instances\n     */\n    function* filesGenerator(): Iterator<\n      DriveFile | { isFile: false; isDirectory: true; prefix: string; name: string }\n    > {\n      for (const directory of response.prefixes) {\n        yield new DriveDirectory(directory.replace(/\\/$/, ''))\n      }\n      for (const file of response.files) {\n        yield new DriveFile(file.name!, self, self.#createFileMetaData(file))\n      }\n    }\n\n    return {\n      paginationToken: response.paginationToken,\n      objects: {\n        [Symbol.iterator]: filesGenerator,\n      },\n    }\n  }\n}\n","/*\n * flydrive\n *\n * (c) FlyDrive\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { debuglog } from 'node:util'\n\nexport default debuglog('flydrive:gcs')\n"],"mappings":"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","names":[]}