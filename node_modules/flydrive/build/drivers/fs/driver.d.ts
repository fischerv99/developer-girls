import { Readable } from 'node:stream';
import type { FSDriverOptions } from './types.js';
import { DriveFile } from '../../src/driver_file.js';
import { DriveDirectory } from '../../src/drive_directory.js';
import type { WriteOptions, ObjectMetaData, DriverContract, ObjectVisibility, SignedURLOptions } from '../../src/types.js';
/**
 * Implementation of FlyDrive driver that uses the local filesystem
 * to persist and read files.
 */
export declare class FSDriver implements DriverContract {
    #private;
    options: FSDriverOptions;
    constructor(options: FSDriverOptions);
    /**
     * Synchronously check if a file exists
     */
    existsSync(key: string): boolean;
    /**
     * Returns a boolean indicating if the file exists or not.
     */
    exists(key: string): Promise<boolean>;
    /**
     * Returns the contents of the file as a UTF-8 string. An
     * exception is thrown when the file is missing.
     */
    get(key: string): Promise<string>;
    /**
     * Returns the contents of the file as a stream. An
     * exception is thrown when the file is missing.
     */
    getStream(key: string): Promise<Readable>;
    /**
     * Returns the contents of the file as an Uint8Array. An
     * exception is thrown when the file is missing.
     */
    getBytes(key: string): Promise<Uint8Array>;
    /**
     * Returns the metadata of a file.
     */
    getMetaData(key: string): Promise<ObjectMetaData>;
    /**
     * Returns the file visibility from the pre-defined config
     * value
     */
    getVisibility(_: string): Promise<ObjectVisibility>;
    /**
     * Returns the public URL of the file. This method does not check
     * if the file exists or not.
     */
    getUrl(key: string): Promise<string>;
    /**
     * Returns the signed/temporary URL of the file. By default, the signed URLs
     * expire in 30mins, but a custom expiry can be defined using
     * "options.expiresIn" property.
     */
    getSignedUrl(key: string, options?: SignedURLOptions): Promise<string>;
    /**
     * Results in noop, since the local filesystem cannot have per
     * object visibility.
     */
    setVisibility(_: string, __: ObjectVisibility): Promise<void>;
    /**
     * Writes a file to the destination with the provided contents.
     *
     * - Missing directories will be created recursively.
     * - Existing file will be overwritten.
     */
    put(key: string, contents: string | Uint8Array, options?: WriteOptions): Promise<void>;
    /**
     * Writes a file to the destination with the provided contents
     * as a readable stream.
     *
     * - Missing directories will be created recursively.
     * - Existing file will be overwritten.
     */
    putStream(key: string, contents: Readable, options?: WriteOptions): Promise<void>;
    /**
     * Copies the source file to the destination. Both paths must
     * be within the root location.
     */
    copy(source: string, destination: string): Promise<void>;
    /**
     * Moves the source file to the destination. Both paths must
     * be within the root location.
     */
    move(source: string, destination: string): Promise<void>;
    /**
     * Deletes a file within the root location of the filesystem.
     * Attempting to delete a non-existing file will result in
     * a noop.
     */
    delete(key: string): Promise<void>;
    /**
     * Deletes the files and directories matching the provided
     * prefix. The method is same as running "rm -rf" unix
     * command
     */
    deleteAll(prefix: string): Promise<void>;
    /**
     * Synchronously delete all files from the root location
     */
    clearSync(): void;
    /**
     * Returns a list of files. The pagination properties are ignored
     * by the fs driver, since it does not support pagination.
     */
    listAll(prefix: string, options?: {
        recursive?: boolean;
        paginationToken?: string;
    }): Promise<{
        paginationToken?: string;
        objects: Iterable<DriveFile | DriveDirectory>;
    }>;
}
