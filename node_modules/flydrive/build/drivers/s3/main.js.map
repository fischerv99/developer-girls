{"version":3,"sources":["../../../drivers/s3/driver.ts","../../../drivers/s3/debug.ts"],"sourcesContent":["/*\n * flydrive\n *\n * (c) FlyDrive\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport mimeTypes from 'mime-types'\nimport { Readable } from 'node:stream'\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'\nimport {\n  S3Client,\n  PutObjectCommand,\n  HeadObjectOutput,\n  GetObjectCommand,\n  HeadObjectCommand,\n  CopyObjectCommand,\n  PutObjectAclCommand,\n  DeleteObjectCommand,\n  GetObjectAclCommand,\n  ListObjectsV2Command,\n  DeleteObjectsCommand,\n  PutObjectCommandInput,\n  GetObjectCommandInput,\n  CopyObjectCommandInput,\n  HeadObjectCommandInput,\n  GetObjectAclCommandInput,\n  PutObjectAclCommandInput,\n  DeleteObjectCommandInput,\n  ListObjectsV2CommandInput,\n  DeleteObjectsCommandInput,\n} from '@aws-sdk/client-s3'\n\nimport debug from './debug.js'\nimport { S3DriverOptions } from './types.js'\nimport { DriveFile } from '../../src/driver_file.js'\nimport { DriveDirectory } from '../../src/drive_directory.js'\nimport type {\n  WriteOptions,\n  DriverContract,\n  ObjectMetaData,\n  ObjectVisibility,\n  SignedURLOptions,\n} from '../../src/types.js'\nimport string from '@poppinss/utils/string'\n\n/**\n * Implementation of FlyDrive driver that reads and persists files\n * to S3 complaint storage services like Digital ocean spaces,\n * R2 and so on.\n */\nexport class S3Driver implements DriverContract {\n  #client: S3Client\n  #supportsACL: boolean = true\n\n  /**\n   * The URI that holds permission for public\n   */\n  publicGrantUri = 'http://acs.amazonaws.com/groups/global/AllUsers'\n\n  constructor(public options: S3DriverOptions) {\n    this.#client = 'client' in options ? options.client : new S3Client(options)\n    if (options.supportsACL !== undefined) {\n      this.#supportsACL = options.supportsACL\n    }\n\n    if (debug.enabled) {\n      debug('driver config %O', {\n        ...options,\n        credentials: 'REDACTED',\n      })\n    }\n  }\n\n  /**\n   * Creates the metadata for the file from the raw response\n   * returned by S3\n   */\n  #createFileMetaData(apiFile: HeadObjectOutput) {\n    const metaData: ObjectMetaData = {\n      contentType: apiFile.ContentType,\n      contentLength: apiFile.ContentLength!,\n      etag: apiFile.ETag!,\n      lastModified: new Date(apiFile.LastModified!),\n    }\n\n    debug('file metadata %O', this.options.bucket, metaData)\n    return metaData\n  }\n\n  /**\n   * Returns S3 options for the save operations.\n   */\n  #getSaveOptions(key: string, options?: WriteOptions): Omit<PutObjectCommandInput, 'Key'> {\n    /**\n     * Destructuring properties needed for local checks. The rest\n     * object will be forwarded to s3 as it is.\n     */\n    const {\n      visibility, // used locally\n      contentType, // forwaded as metadata\n      cacheControl, // forwaded as metadata\n      contentEncoding, // forwaded as metadata\n      contentLength, // forwaded as metadata\n      contentLanguage, // forwaded as metadata\n      contentDisposition, // forwaded as metadata\n      ...rest // forwarded as it is\n    } = options || {}\n\n    /**\n     * Creating S3 options with all the known and unknown properties\n     */\n    const s3Options: Omit<PutObjectCommandInput, 'Key'> = {\n      Bucket: this.options.bucket,\n      ...rest,\n    }\n\n    /**\n     * Set ACL when service supports it\n     */\n    if (this.#supportsACL) {\n      const isPublic = (visibility || this.options.visibility) === 'public'\n      s3Options.ACL = isPublic ? 'public-read' : 'private'\n    }\n\n    if (contentType) {\n      s3Options.ContentType = contentType\n    } else {\n      const detectedContentType = mimeTypes.lookup(key)\n      if (detectedContentType) {\n        debug('setting \"%s\" file\\'s content-type to \"%s\"', key, detectedContentType)\n        s3Options.ContentType = detectedContentType\n      }\n    }\n\n    if (cacheControl) {\n      s3Options.CacheControl = cacheControl\n    }\n    if (contentEncoding) {\n      s3Options.ContentEncoding = contentEncoding\n    }\n    if (contentLength) {\n      s3Options.ContentLength = contentLength\n    }\n    if (contentLanguage) {\n      s3Options.ContentLanguage = contentLanguage\n    }\n    if (contentDisposition) {\n      s3Options.ContentDisposition = contentDisposition\n    }\n\n    debug('s3 write options %O', s3Options)\n    return s3Options\n  }\n\n  /**\n   * Deletes files recursively with a batch of 1000 files at a time\n   */\n  async #deleteFilesRecursively(prefix: string, paginationToken?: string) {\n    /**\n     * Get a list of 1000 files\n     */\n    const response = await this.#client.send(\n      this.createListObjectsV2Command(this.#client, {\n        Bucket: this.options.bucket,\n        ContinuationToken: paginationToken,\n        ...(prefix !== '/' ? { Prefix: prefix } : {}),\n      })\n    )\n\n    /**\n     * Return early if no files exists\n     */\n    if (!response.Contents || !response.Contents.length) {\n      return\n    }\n\n    /**\n     * Delete all files\n     */\n    await this.#client.send(\n      this.createDeleteObjectsCommand(this.#client, {\n        Bucket: this.options.bucket,\n        Delete: {\n          Objects: Array.from(response.Contents).map((file) => {\n            return {\n              Key: file.Key,\n            }\n          }),\n          Quiet: true,\n        },\n      })\n    )\n\n    if (response.NextContinuationToken) {\n      debug('deleting next batch of files with token %s', response.NextContinuationToken)\n      await this.#deleteFilesRecursively(prefix, response.NextContinuationToken)\n    }\n  }\n\n  /**\n   * Creates S3 \"PutObjectCommand\". Feel free to override this method to\n   * manually create the command\n   */\n  protected createPutObjectCommand(_: S3Client, options: PutObjectCommandInput) {\n    return new PutObjectCommand(options)\n  }\n\n  /**\n   * Creates S3 \"GetObjectCommand\". Feel free to override this method to\n   * manually create the command\n   */\n  protected createGetObjectCommand(_: S3Client, options: GetObjectCommandInput) {\n    return new GetObjectCommand(options)\n  }\n\n  /**\n   * Creates S3 \"HeadObjectCommand\". Feel free to override this method to\n   * manually create the command\n   */\n  protected createHeadObjectCommand(_: S3Client, options: HeadObjectCommandInput) {\n    return new HeadObjectCommand(options)\n  }\n\n  /**\n   * Creates S3 \"GetObjectAclCommand\". Feel free to override this method to\n   * manually create the command\n   */\n  protected createGetObjectAclCommand(_: S3Client, options: GetObjectAclCommandInput) {\n    return new GetObjectAclCommand(options)\n  }\n\n  /**\n   * Creates S3 \"PutObjectAclCommand\". Feel free to override this method to\n   * manually create the command\n   */\n  protected createPutObjectAclCommand(_: S3Client, options: PutObjectAclCommandInput) {\n    return new PutObjectAclCommand(options)\n  }\n\n  /**\n   * Creates S3 \"DeleteObjectCommand\". Feel free to override this method to\n   * manually create the command\n   */\n  protected createDeleteObjectCommand(_: S3Client, options: DeleteObjectCommandInput) {\n    return new DeleteObjectCommand(options)\n  }\n\n  /**\n   * Creates S3 \"CopyObjectCommand\". Feel free to override this method to\n   * manually create the command\n   */\n  protected createCopyObjectCommand(_: S3Client, options: CopyObjectCommandInput) {\n    return new CopyObjectCommand(options)\n  }\n\n  /**\n   * Creates S3 \"ListObjectsV2Command\". Feel free to override this method to\n   * manually create the command\n   */\n  protected createListObjectsV2Command(_: S3Client, options: ListObjectsV2CommandInput) {\n    return new ListObjectsV2Command(options)\n  }\n\n  /**\n   * Creates S3 \"DeleteObjectsCommand\". Feel free to override this method to\n   * manually create the command\n   */\n  protected createDeleteObjectsCommand(_: S3Client, options: DeleteObjectsCommandInput) {\n    return new DeleteObjectsCommand(options)\n  }\n\n  /**\n   * Returns a boolean indicating if the file exists\n   * or not.\n   */\n  async exists(key: string): Promise<boolean> {\n    debug('checking if file exists %s:%s', this.options.bucket, key)\n    try {\n      const response = await this.#client.send(\n        this.createHeadObjectCommand(this.#client, {\n          Key: key,\n          Bucket: this.options.bucket,\n        })\n      )\n      return response.$metadata.httpStatusCode === 200\n    } catch (error) {\n      if (error.$metadata?.httpStatusCode === 404) {\n        return false\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Returns the contents of a file as a UTF-8 string. An\n   * exception is thrown when object is missing.\n   */\n  async get(key: string): Promise<string> {\n    debug('reading file contents %s:%s', this.options.bucket, key)\n    const response = await this.#client.send(\n      this.createGetObjectCommand(this.#client, {\n        Key: key,\n        Bucket: this.options.bucket,\n      })\n    )\n\n    return response.Body!.transformToString()\n  }\n\n  /**\n   * Returns the contents of the file as a Readable stream. An\n   * exception is thrown when the file is missing.\n   */\n  async getStream(key: string): Promise<Readable> {\n    debug('reading file contents as a stream %s:%s', this.options.bucket, key)\n    const response = await this.#client.send(\n      this.createGetObjectCommand(this.#client, {\n        Key: key,\n        Bucket: this.options.bucket,\n      })\n    )\n\n    return response.Body! as Readable\n  }\n\n  /**\n   * Returns the contents of the file as an Uint8Array. An\n   * exception is thrown when the file is missing.\n   */\n  async getBytes(key: string): Promise<Uint8Array> {\n    debug('reading file contents as array buffer %s:%s', this.options.bucket, key)\n    const response = await this.#client.send(\n      this.createGetObjectCommand(this.#client, {\n        Key: key,\n        Bucket: this.options.bucket,\n      })\n    )\n\n    return response.Body!.transformToByteArray()\n  }\n\n  /**\n   * Returns the file metadata.\n   */\n  async getMetaData(key: string): Promise<ObjectMetaData> {\n    debug('fetching file metadata %s:%s', this.options.bucket, key)\n    const response = await this.#client.send(\n      this.createHeadObjectCommand(this.#client, {\n        Key: key,\n        Bucket: this.options.bucket,\n      })\n    )\n\n    return this.#createFileMetaData(response)\n  }\n\n  /**\n   * Returns the visibility of a file\n   */\n  async getVisibility(key: string): Promise<ObjectVisibility> {\n    if (!this.#supportsACL) {\n      return this.options.visibility\n    }\n\n    debug('fetching file visibility %s:%s', this.options.bucket, key)\n    const response = await this.#client.send(\n      this.createGetObjectAclCommand(this.#client, {\n        Key: key,\n        Bucket: this.options.bucket,\n      })\n    )\n\n    const isPublic = (response.Grants || []).find((grant) => {\n      return (\n        grant.Grantee?.URI === this.publicGrantUri &&\n        (grant.Permission === 'READ' || grant.Permission === 'FULL_CONTROL')\n      )\n    })\n\n    return isPublic ? 'public' : 'private'\n  }\n\n  /**\n   * Returns the public URL of the file. This method does not check\n   * if the file exists or not.\n   */\n  async getUrl(key: string): Promise<string> {\n    /**\n     * Use custom implementation when exists.\n     */\n    const generateURL = this.options.urlBuilder?.generateURL\n    if (generateURL) {\n      debug('using custom implementation for generating public URL %s:%s', this.options.bucket, key)\n      return generateURL(key, this.options.bucket, this.#client)\n    }\n\n    debug('generating file URL %s:%s', this.options.bucket, key)\n\n    /**\n     * Make sure using CDN URL property\n     */\n    if (this.options.cdnUrl) {\n      return new URL(key, this.options.cdnUrl).toString()\n    }\n\n    /**\n     * Use endpoint from the config (when available)\n     */\n    if (this.#client.config.endpoint) {\n      const endpoint = await this.#client.config.endpoint()\n\n      return new URL(\n        `/${this.options.bucket}/${key}`,\n        `${endpoint.protocol}//${endpoint.hostname}`\n      ).toString()\n    }\n\n    /**\n     * Otherwise fallback to AWS based URL\n     */\n    return new URL(`/${key}`, `https://${this.options.bucket}.s3.amazonaws.com`).toString()\n  }\n\n  /**\n   * Returns the signed/temporary URL of the file. By default, the signed URLs\n   * expire in 30mins, but a custom expiry can be defined using\n   * \"options.expiresIn\" property.\n   */\n  async getSignedUrl(key: string, options?: SignedURLOptions): Promise<string> {\n    const { contentDisposition, contentType, expiresIn, ...rest } = Object.assign({}, options)\n\n    /**\n     * Options passed to GCS when generating the signed URL.\n     */\n    const expires = string.seconds.parse(expiresIn || '30mins')\n\n    /**\n     * Options given to the GetObjectCommand when create a signed\n     * URL\n     */\n    const signedURLOptions: GetObjectCommandInput = {\n      Key: key,\n      Bucket: this.options.bucket,\n      ResponseContentType: contentType,\n      ResponseContentDisposition: contentDisposition,\n      ...rest,\n    }\n\n    /**\n     * Use custom implementation when exists.\n     */\n    const generateSignedURL = this.options.urlBuilder?.generateSignedURL\n    if (generateSignedURL) {\n      debug('using custom implementation for generating signed URL %s:%s', this.options.bucket, key)\n      return generateSignedURL(key, signedURLOptions, this.#client)\n    }\n\n    debug('generating signed URL %s:%s', this.options.bucket, key)\n    return getSignedUrl(this.#client, this.createGetObjectCommand(this.#client, signedURLOptions), {\n      expiresIn: expires,\n    })\n  }\n\n  /**\n   * Updates the visibility of a file\n   */\n  async setVisibility(key: string, visibility: ObjectVisibility): Promise<void> {\n    if (!this.#supportsACL) {\n      return\n    }\n\n    debug('updating file visibility %s:%s to %s', this.options.bucket, key, visibility)\n    await this.#client.send(\n      this.createPutObjectAclCommand(this.#client, {\n        Key: key,\n        Bucket: this.options.bucket,\n        ACL: visibility === 'public' ? 'public-read' : 'private',\n      })\n    )\n  }\n\n  /**\n   * Writes a file to the bucket for the given key and contents.\n   */\n  async put(\n    key: string,\n    contents: string | Uint8Array,\n    options?: WriteOptions | undefined\n  ): Promise<void> {\n    debug('creating/updating file %s:%s', this.options.bucket, key)\n\n    const command = this.createPutObjectCommand(this.#client, {\n      ...this.#getSaveOptions(key, options),\n      Key: key,\n      Body: contents,\n    })\n\n    await this.#client.send(command)\n  }\n\n  /**\n   * Writes a file to the bucket for the given key and stream\n   */\n  putStream(key: string, contents: Readable, options?: WriteOptions | undefined): Promise<void> {\n    debug('creating/updating file %s:%s', this.options.bucket, key)\n\n    return new Promise((resolve, reject) => {\n      /**\n       * GCS internally creates a pipeline of stream and invokes the \"_destroy\" method\n       * at several occassions. Because of that, the \"_destroy\" method emits an event\n       * which cannot handled within this block of code.\n       *\n       * So the only way I have been able to make GCS streams work is by ditching the\n       * pipeline method and relying on the \"pipe\" method instead.\n       */\n      contents.once('error', reject)\n      const command = this.createPutObjectCommand(this.#client, {\n        ...this.#getSaveOptions(key, options),\n        Key: key,\n        Body: contents,\n      })\n\n      return this.#client\n        .send(command)\n        .then(() => resolve())\n        .catch(reject)\n    })\n  }\n\n  /**\n   * Copies the source file to the destination. Both paths must\n   * be within the root location.\n   */\n  async copy(source: string, destination: string, options?: WriteOptions): Promise<void> {\n    debug(\n      'copying file from %s:%s to %s:%s',\n      this.options.bucket,\n      source,\n      this.options.bucket,\n      destination\n    )\n\n    options = options || {}\n\n    /**\n     * Copy visibility from the source file to the\n     * destination when no inline visibility is\n     * defined\n     */\n    if (!options.visibility && this.#supportsACL) {\n      options.visibility = await this.getVisibility(source)\n    }\n\n    await this.#client.send(\n      this.createCopyObjectCommand(this.#client, {\n        ...this.#getSaveOptions(destination, options),\n        Key: destination,\n        CopySource: `/${this.options.bucket}/${source}`,\n        Bucket: this.options.bucket,\n      })\n    )\n  }\n\n  /**\n   * Moves the source file to the destination. Both paths must\n   * be within the root location.\n   */\n  async move(source: string, destination: string, options?: WriteOptions): Promise<void> {\n    debug(\n      'moving file from %s:%s to %s:%s',\n      this.options.bucket,\n      source,\n      this.options.bucket,\n      destination\n    )\n\n    await this.copy(source, destination, options)\n    await this.delete(source)\n  }\n\n  /**\n   * Deletes the object from the bucket\n   */\n  async delete(key: string) {\n    debug('removing file %s:%s', this.options.bucket, key)\n\n    await this.#client.send(\n      this.createDeleteObjectCommand(this.#client, {\n        Key: key,\n        Bucket: this.options.bucket,\n      })\n    )\n  }\n\n  /**\n   * Deletes the files and directories matching the provided\n   * prefix.\n   */\n  async deleteAll(prefix: string): Promise<void> {\n    debug('removing all files matching prefix %s:%s', this.options.bucket, prefix)\n    await this.#deleteFilesRecursively(prefix)\n  }\n\n  /**\n   * Returns a list of files. The pagination token can be used to paginate\n   * through the files.\n   */\n  async listAll(\n    prefix: string,\n    options?: {\n      recursive?: boolean\n      paginationToken?: string\n      maxResults?: number\n    }\n  ): Promise<{\n    paginationToken?: string\n    objects: Iterable<DriveFile | DriveDirectory>\n  }> {\n    const self = this\n    let { recursive, paginationToken, maxResults } = Object.assign({ recursive: false }, options)\n    if (prefix) {\n      prefix = !recursive ? `${prefix.replace(/\\/$/, '')}/` : prefix\n    }\n\n    debug('listing all files matching prefix %s:%s', this.options.bucket, prefix)\n\n    const response = await this.#client.send(\n      this.createListObjectsV2Command(this.#client, {\n        Bucket: this.options.bucket,\n        Delimiter: !recursive ? '/' : '',\n        ContinuationToken: paginationToken,\n        ...(prefix !== '/' ? { Prefix: prefix } : {}),\n        ...(maxResults !== undefined ? { MaxKeys: maxResults } : {}),\n      })\n    )\n\n    /**\n     * The generator is used to lazily iterate over files and\n     * convert them into DriveFile or DriveDirectory instances\n     */\n    function* filesGenerator(): Iterator<\n      DriveFile | { isFile: false; isDirectory: true; prefix: string; name: string }\n    > {\n      if (response.CommonPrefixes) {\n        for (const directory of response.CommonPrefixes) {\n          yield new DriveDirectory(directory.Prefix!.replace(/\\/$/, ''))\n        }\n      }\n      if (response.Contents) {\n        for (const file of response.Contents) {\n          yield new DriveFile(file.Key!, self, self.#createFileMetaData(file))\n        }\n      }\n    }\n\n    return {\n      paginationToken: response.NextContinuationToken,\n      objects: {\n        [Symbol.iterator]: filesGenerator,\n      },\n    }\n  }\n}\n","/*\n * flydrive\n *\n * (c) FlyDrive\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { debuglog } from 'node:util'\n\nexport default debuglog('flydrive:s3')\n"],"mappings":"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","names":[]}